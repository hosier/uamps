//------------------------------------------------------------------------------------
// Hello.c
//------------------------------------------------------------------------------------
//8051 Test program to demonstrate serial port I/O.  This program writes a message on
//the console using the printf() function, and reads characters using the getchar()
//function.  An ANSI escape sequence is used to clear the screen if a '2' is typed.
//A '1' repeats the message and the program responds to other input characters with
//an appropriate message.
//------------------------------------------------------------------------------------
// Includes
//------------------------------------------------------------------------------------
#include <c8051f120.h>
#include <final_config.c>


//------------------------------------------------------------------------------------
// Global Constants
//------------------------------------------------------------------------------------



//------------------------------------------------------------------------------------
// Function Prototypes
//------------------------------------------------------------------------------------
void main(void);
void timer2_ISR(void) __interrupt 5;
void disable_transmission(void);
void enable_transmission(void);

//------------------------------------------------------------------------------------
// Global Variables
//------------------------------------------------------------------------------------

unsigned char state; //current bit being FSK modulated
unsigned char next_state; //next calculated bit to FSK modulate

unsigned char count;	//current number of FSK cycles*2
unsigned char max_count; //max number of FSK cycles before changing bits
unsigned char num_0; //used to alternate timing lengths

unsigned char ready; //flag to indicate ready to calculate next_state

unsigned char bit_val; //used to read a single bit from the whole piece of data

unsigned int header = 0x05;	//hard coded header info
unsigned long card_data = 0xAAAAAAAA; //hard coded card info: **LSB is transmitted first**

//------------------------------------------------------------------------------------
// MAIN Routine
//------------------------------------------------------------------------------------
void main(void)
{
	unsigned long temp_bits; //temp location to cycle through the bits of the data to send
	Init_Device(); //config files generated by Configuration Wizard
	state = 1; //initial state to use, will be
	max_count = 10; //initial max_count to use

	SFRPAGE = TMR2_PAGE;//not necessary?

	while(1) //main while loop
	{
		unsigned int i; //counter variable used in for loops
		temp_bits = (unsigned int) header; //fill temp_bits with the header data;
		for(i = 0; i<10;i++) //send the RFID header, non manchester encoded
		{
			next_state = temp_bits&0x01;
			ready = 0;
			while(!ready);
			temp_bits=temp_bits>>1;
		}

		//**TODO** 2 parity bits

		temp_bits = card_data; //load card data into temp_bits, temp bits is bitshifted once per loop to read individual bits at LSB
		for(i = 0; i<31; i++) //send the 31 bits of the card data manchester encoded
		{
			bit_val = temp_bits&0x01;
			switch(bit_val)	//switch statment for manchester encoding
			{
				case(0):	//if bit_val is 0, send 1 then 0
					next_state = 1;
					ready = 0;
					while(!ready);	//wait for timer2_isr to be ready for next_state
					ready = 0;
					next_state = 0;
					while(!ready);	//wait for timer2_isr to be ready for next_state
					break;
				case(1):	//if bit_val is 1, send 0 then 1
					next_state = 0;
					ready = 0;
					while(!ready);	//wait for timer2_isr to be ready for next_state
					next_state = 1;
					ready = 0;
					while(!ready);
					break;
			}
			temp_bits = temp_bits>>1;	//shift temp_bits over by one so that next bit is in LSB position
		}

		//**TODO**end parity bit

	}
}


void timer2_ISR(void) __interrupt 5 //this is where the data is modulated for FSK
{
	count ++;	//increment the number of FSK cycles completed
	if(count >= max_count)	//if the necessary number of FSK cycles is reached, prepare to send next bit
	{
		count = 0;	//reset number of FSK cycles
		switch(next_state)	//timer2 timing and number of FSK cycles depends on next desired data transmission
		{
			case(0):	//if next bit is 0, set up timer2 for the correct FSK frequency and duration
				state = 0;
				num_0 ++;	//increment number of 0's to enable balancing of 0 duration with 1 duration
				switch(num_0%4)	//every 4th 0 needs to be a little longer so that average duration of FSK 0 is 50 RF cycles
				{
					case(1):
						max_count = 14;	//7 FSK cycles = 56 RF cycles
						break;
					default:
						max_count = 12;	//6 FSK cycles = 48 RF cycles
						break;
				}										//56*1/4 + 48*3/4 = 50 RF cycles
				RCAP2L = 0xF0;	//1 FSK cycle every 4 RF cycles
				break;
			case(1):
				state = 1;
				max_count = 10;	//5 FSK cycles total = 50 RF cycles
				RCAP2L = 0x2C;	//1 FSK cycle every 5 RF cycles
				break;
		}
		ready = 1;
	}
	//P1 = state;
	TF2 = 0;
}

void disable_transmission(void)	//used to stop timer2 for when we aren't trying to emulate a card
{
	char SFR_PAGE_SAVE = SFRPAGE;
	SFRPAGE = TMR2_PAGE;
	TMR2CN = 0x00;
	SFRPAGE = SFR_PAGE_SAVE;
	P0 = 0;
	P1 = 0;
}

void enable_transmission(void)	//used to restart timer2 and enable spoofing of a card
{
	char SFR_PAGE_SAVE = SFRPAGE;
	SFRPAGE = TMR2_PAGE;
	TMR2CN = 0x04;
	SFRPAGE = SFR_PAGE_SAVE;
}
